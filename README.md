# ClassUtil
ClassUtil是一个原型类工具，编写一次原型脚本, 可以同时生成Java原型类和C++原型类. 主要用于Java跟C++通信的场合。

下载源码后修改main函数中脚本文件路径即可使用。

脚本文件采用thrift语法, 
目前支持thrift基础数据类型以及list,set,map三种集合类型，其中集合类型最多嵌套两层; 
支持脚本之间include引用; 
支持命名空间设置;
脚本中存在的注释自动写入到Java和C++结果代码中。

输出的C++代码自动引用了jsoncpp库，可以自动从json中解析对象, 可以一键toJsonString。 
json库地址在这里: 
https://github.com/addriumruss/json

遇到问题请随时提问, 欢迎探讨~

示例:
thrift脚本:
namespace cpp demo
namespace java com.shg.edu.sch

//include "other.thrift"

/** 这个是学校对象 */
struct School{
    /** 名称, 注意字段需要附带索引和optional或required标志 */
	1: optional string name, 
	/** 序号 */
	2: optional i64 sn = 0l, 
}

/** 这个是学生对象 */
struct Student{
    /** 名称, 注意字段需要附带索引和optional或required标志 */
	1: optional string name, 
	/** 消息的序列号 */
	2: optional i32 id = 128, 
}

生成的c++代码:
demo.h:
#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <algorithm>
#include <array>
#include <ciso646>
#include <forward_list>
#include <iterator>
#include <map>
#include <vector>
#include <set>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <utility>
#include <valarray>

//nlohmann/json
#include <nlohmann/json.hpp>
using json = nlohmann::json;

#include "BaseTypes.h"

using namespace std;

namespace demo { 
/**
通用基础数据类定义
2018-09-20, russ
*/


//include "other.thrift"

/** 这个是学校对象 */
class School: public JsonBase {
public: 
    /** 名称, 注意字段需要附带索引和optional或required标志 */
    string name;
    /** 序号 */
    int64_t sn = 0l;
public: 
    /** 注意: 返回结果需要delete释放! */
    virtual School* parseFromJson(const json& jsonObj) {
        const string jsonObjDumpString = jsonObj.dump(); /* 必须先传输到string结构中才能有效 */
        const char *dumpstr = jsonObjDumpString.c_str();
        debug_printf("[info] School json.dump= %s \n", dumpstr);
        debug_printf("[info] School 解析属性: %s \n", "name");
        if(strstr(dumpstr, "\"name\"")) {
            name = jsonObj["name"];
        }
        debug_printf("[info] School 解析属性: %s \n", "sn");
        if(strstr(dumpstr, "\"sn\"")) {
            sn = jsonObj["sn"];
        }
        return this;
    }
    /** 注意: 返回结果需要free释放! */
    virtual char* toJsonString() {
        debug_printf("School 构建json对象 \n");
        json jsonObj;
        debug_printf("School 序列化字段: %s\n ","name");
        if(!name.empty()) {
            jsonObj["name"] = name;
        }
        debug_printf("School 序列化字段: %s\n ","sn");
        jsonObj["sn"] = sn;

        debug_printf("School 创建并输出字符串 \n");
        string jsonStr = jsonObj.dump();
        int jsonLen = jsonStr.length();
        char *res = (char*)malloc(jsonLen+1);
        if(!res) {
            printf("School 内存不足, toJsonString失败!\n");
            return NULL;
        }
        memcpy(res, jsonStr.c_str(), jsonLen);
        res[jsonLen] = 0;
        return res;
    }
public:
    School() {
        sn = 0;
    }
    virtual ~School() {
        // 开始释放对象 
        //TODO, 在这里添加额外的释放处理
    }
};

/** 这个是学生对象 */
class Student: public JsonBase {
public: 
    /** 名称, 注意字段需要附带索引和optional或required标志 */
    string name;
    /** 消息的序列号 */
    int32_t id = 128;
public: 
    /** 注意: 返回结果需要delete释放! */
    virtual Student* parseFromJson(const json& jsonObj) {
        const string jsonObjDumpString = jsonObj.dump(); /* 必须先传输到string结构中才能有效 */
        const char *dumpstr = jsonObjDumpString.c_str();
        debug_printf("[info] Student json.dump= %s \n", dumpstr);
        debug_printf("[info] Student 解析属性: %s \n", "name");
        if(strstr(dumpstr, "\"name\"")) {
            name = jsonObj["name"];
        }
        debug_printf("[info] Student 解析属性: %s \n", "id");
        if(strstr(dumpstr, "\"id\"")) {
            id = jsonObj["id"];
        }
        return this;
    }
    /** 注意: 返回结果需要free释放! */
    virtual char* toJsonString() {
        debug_printf("Student 构建json对象 \n");
        json jsonObj;
        debug_printf("Student 序列化字段: %s\n ","name");
        if(!name.empty()) {
            jsonObj["name"] = name;
        }
        debug_printf("Student 序列化字段: %s\n ","id");
        jsonObj["id"] = id;

        debug_printf("Student 创建并输出字符串 \n");
        string jsonStr = jsonObj.dump();
        int jsonLen = jsonStr.length();
        char *res = (char*)malloc(jsonLen+1);
        if(!res) {
            printf("Student 内存不足, toJsonString失败!\n");
            return NULL;
        }
        memcpy(res, jsonStr.c_str(), jsonLen);
        res[jsonLen] = 0;
        return res;
    }
public:
    Student() {
        id = 0;
    }
    virtual ~Student() {
        // 开始释放对象 
        //TODO, 在这里添加额外的释放处理
    }
};

} 

生成的Java代码:
School.java:
package com.shg.edu.sch;

import java.util.*;

import org.springframework.data.annotation.Id;

import com.utm.util.IModel;

@SuppressWarnings({"unused"})
@javax.annotation.Generated(value = "Autogenerated by ClassUtil Compiler (0.1)", date = "2018-12-20")
public class School implements IModel {
    private static final long serialVersionUID = 1L;

    /** 名称, 注意字段需要附带索引和optional或required标志 */
    public String name;
	/** 序号 */
    public Long sn = 0l;

    public School(){
    }

    public final String getName() { 
        return name; 
    }

    public final void setName(String name) { 
        this.name = name;
    }

    public final Long getSn() { 
        return sn; 
    }

    public final void setSn(Long sn) { 
        this.sn = sn;
    }


}

Student.java:
package com.shg.edu.sch;

import java.util.*;

import org.springframework.data.annotation.Id;

import com.utm.util.IModel;

@SuppressWarnings({"unused"})
@javax.annotation.Generated(value = "Autogenerated by ClassUtil Compiler (0.1)", date = "2018-12-20")
public class Student implements IModel {
    private static final long serialVersionUID = 1L;

    /** 名称, 注意字段需要附带索引和optional或required标志 */
    public String name;
	/** 消息的序列号 */
    public Integer id = 128;

    public Student(){
        id = 0;
    }

    public final String getName() { 
        return name; 
    }

    public final void setName(String name) { 
        this.name = name;
    }

    public final Integer getId() { 
        return id; 
    }

    public final void setId(Integer id) { 
        this.id = id;
    }


}


